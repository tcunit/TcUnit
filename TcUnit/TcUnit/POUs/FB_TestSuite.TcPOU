<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_TestSuite" Id="{f80c23f2-119d-406b-ae11-06d1991bf64d}" SpecialFunc="None">
    <Declaration><![CDATA[(* This function block is responsible for holding the internal state of the test suite.
   Every test suite can have one or more tests, and every test can do one or more asserts.
   It's also responsible for providing all the assert-methods for asserting different data types.
   Only failed assertions are recorded.
*)
{attribute 'call_after_init'}
{attribute 'reflection'}
FUNCTION_BLOCK FB_TestSuite
VAR
    {attribute 'instance-path'}
    {attribute 'noinit'}
    InstancePath : Tc2_System.T_MaxString;

    (* We need to have access to specific information of the current task that this test suite
       is executed in. This is for instance necessary when we need to know whether a test is
       defined already. The definition of a test that is defined already is that we call on it
       with the same name twice in the same cycle *)
    GetCurrentTaskIndex : Tc2_System.GETCURTASKINDEX;

    NumberOfTests : UINT := 0;
    Tests : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF FB_Test;
    (* Rising trigger of whether we have already notified the user of that the test name pointed to by the current
       position is a duplicate *)
    TestDuplicateNameTrigger : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF Tc2_Standard.R_TRIG;
    (* Last cycle count index for a specific test. Used to detect whether this test has already been defined in the
       current test suite *)
    TestCycleCountIndex : ARRAY[1..GVL_Param_TcUnit.MaxNumberOfTestsForEachTestSuite] OF UDINT;

    AssertResults : FB_AssertResultStatic;
    AssertArrayResult : FB_AssertArrayResultStatic;

    (* Prints the failed asserts to ADS so that Visual Studio can display the assert message.
       This assert formatter can be replaced with something else than ADS *)
    ADSAssertMessageFormatter : FB_ADSAssertMessageFormatter;
    AssertMessageFormatter : I_AssertMessageFormatter := ADSAssertMessageFormatter;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="AddTest" Id="{d383011f-6bea-4b05-9018-ea4782ad2837}">
      <Declaration><![CDATA[METHOD PUBLIC AddTest
VAR_INPUT
    TestName : Tc2_System.T_MaxString;
END_VAR
VAR
    IteratorCounter : UINT;
    ErrorMessage : Tc2_System.T_MaxString;
    TestInstancePath : Tc2_System.T_MaxString;
    FunctionCallResult : DINT;
    CycleCount : UDINT;
    TestWithThisNameAlreadyExists : BOOL := FALSE;
    LowerCasedTestName : Tc2_System.T_MaxString;
    TrimmedTestName : Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[GVL_TcUnit.IgnoreCurrentTest := FALSE; // Reset the ignore current test flag

TrimmedTestName := Tc2_Utilities.F_LTrim(in := TestName);
TrimmedTestName := Tc2_Utilities.F_RTrim(in := TrimmedTestName);
LowerCasedTestName := Tc2_Utilities.F_ToLCase(in := TrimmedTestName);

(* Check if this test should be disabled *)
IF Tc2_Utilities.FIND(STR1 := LowerCasedTestName, STR2 := 'disabled_') = 1 THEN
    GVL_TcUnit.IgnoreCurrentTest := TRUE;
    RETURN;
END_IF

GetCurrentTaskIndex(); // Gets the task index of where this function block instance is being run in

(* Check if the test name already exists. Make sure there are no other tests with the same name already
   added for this test suite *)

CycleCount := TwinCAT_SystemInfoVarList._TaskInfo[GetCurrentTaskIndex.index].CycleCount;

(* Iterate all the test names that up to this point have been added for this test suite *)
FOR IteratorCounter := 1 TO NumberOfTests BY 1 DO
    IF Tests[IteratorCounter].GetName() = TrimmedTestName THEN
        TestWithThisNameAlreadyExists := TRUE;
        (* Check if a test with this name has already been called in this PLC cycle *)
        IF TestCycleCountIndex[IteratorCounter] = CycleCount THEN
            GVL_TcUnit.IgnoreCurrentTest := TRUE;
            (* A test with this name already exists for this test suite and has already been called in this cycle.
               Send a message notification, but only if we have not done so already. *)
            TestDuplicateNameTrigger[IteratorCounter](CLK := TRUE);
            IF TestDuplicateNameTrigger[IteratorCounter].Q THEN // Rising edge detected. We have not reported this before
                TestInstancePath := F_RemoveInstancePathAndProjectNameFromTestInstancePath(TestInstancePath :=
                                                                                           GVL_TcUnit.CurrentTestSuiteBeingCalled^.GetInstancePath());
                ErrorMessage := 'Test with name $'%s$' already exists in test suite $'';
                ErrorMessage := Tc2_Standard.CONCAT(STR1 := ErrorMessage, STR2 := TestInstancePath);
                ErrorMessage := Tc2_Standard.CONCAT(STR1 := ErrorMessage, STR2 := '$'');
                GVL_TcUnit.AdsLogger.WriteLog(MsgFmtStr := ErrorMessage,
                                              StrArg := TrimmedTestName);
            END_IF
        END_IF
        TestCycleCountIndex[IteratorCounter] := CycleCount;
    END_IF
END_FOR

IF NOT TestWithThisNameAlreadyExists THEN
    (* Test has not been found. Add it. *)
    Tests[IteratorCounter].SetName(Name := TrimmedTestName);
    NumberOfTests := NumberOfTests + 1;
    TestCycleCountIndex[NumberOfTests] := CycleCount;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AddTestNameToInstancePath" Id="{abecfe2f-b0e2-4118-a1c6-bb248556b776}">
      <Declaration><![CDATA[METHOD PRIVATE AddTestNameToInstancePath : Tc2_System.T_MaxString
VAR_INPUT
    TestInstancePath : Tc2_System.T_MaxString;
END_VAR
VAR
    CompleteTestInstancePath : Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CompleteTestInstancePath := Tc2_Utilities.CONCAT(STR1 := TestInstancePath, STR2 := '@');
AddTestNameToInstancePath := Tc2_Utilities.CONCAT(STR1 := CompleteTestInstancePath, STR2 := GVL_TcUnit.CurrentTestNameBeingCalled);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AllTestsFinished" Id="{2b211901-49a8-4e51-90e1-4b1e298f9e0c}">
      <Declaration><![CDATA[METHOD PUBLIC AllTestsFinished : BOOL
VAR
    Counter : UINT;

    GetCurTaskIndex : Tc2_System.GETCURTASKINDEX;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[AllTestsFinished := FALSE;

IF NumberOfTests > 0 THEN
    AllTestsFinished := TRUE;
    FOR Counter := 1 TO GetNumberOfTests() BY 1 DO
        AllTestsFinished := AllTestsFinished AND Tests[Counter].IsFinished();
    END_FOR
END_IF

(* If we have been running at least one cycle and no tests are registered it means that this testsuite is empty
   and doesn't contain any test cases. In that case, add a warning message and ignore this testsuite. *)
GetCurTaskIndex();
IF NumberOfTests = 0 AND NOT TwinCAT_SystemInfoVarList._TaskInfo[GetCurTaskIndex.index].FirstCycle THEN
    AllTestsFinished := TRUE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArray2dEquals_LREAL" Id="{964c2fec-9de7-47ae-bee4-23c559ae4a3f}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArray2dEquals_LREAL
VAR_IN_OUT
    Expecteds : ARRAY[*,*] OF LREAL; // LREAL 2d array with expected values
    Actuals : ARRAY[*,*] OF LREAL; // LREAL 2d array with actual values
END_VAR
VAR_INPUT
    Delta : LREAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    DimensionIndex : USINT; // Index when looping through Dimensions
    LowerBoundExpecteds : ARRAY[1..2] OF DINT; // Lower bounds of Expecteds array in each dimension
    UpperBoundExpecteds : ARRAY[1..2] OF DINT; // Upper bounds of Expecteds array in each dimension
    LowerBoundActuals : ARRAY[1..2] OF DINT; // Lower bounds of Actuals array in each dimension
    UpperBoundActuals : ARRAY[1..2] OF DINT; // Upper bounds of Actuals array in each dimension
    SizeOfExpecteds : ARRAY[1..2] OF DINT; // Size of Expecteds array in each dimension
    SizeOfActuals : ARRAY[1..2] OF DINT; // Size of Actuals array in each dimension
    Offset : ARRAY[1..2] OF DINT; // Current Array index offsets from Lower Bound in each dimension
    ExpectedArrayIndex : ARRAY[1..2] OF DINT; // Array of current Expected array indexes when looping through arrays
    ActualArrayIndex : ARRAY[1..2] OF DINT; // Array of current Actual array indexes when looping through arrays
    Expected : LREAL; // Single expected value
    Actual : LREAL; // Single actual value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,
   so they can't be called in a dimension-based loop.
   Thus we copy the array dimensions into arrays which accept variable indexes *)
LowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);
UpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);
LowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);
UpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);
LowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);
UpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);
LowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);
UpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);

FOR DimensionIndex := 1 TO 2 DO
    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;
    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;

    IF SizeOfExpecteds[DimensionIndex] <> SizeOfActuals[DimensionIndex] THEN
        Equals := FALSE;
        SizeEquals := FALSE;
    END_IF
END_FOR

IF SizeEquals THEN
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes in each dimension, which needs to be taken into account. *)
    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1
        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2
            // Update index variables
            FOR DimensionIndex := 1 TO 2 DO
                ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];
                ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];
            END_FOR

            // Get array element values
            Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2]];
            Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2]]; 

            IF ABS(Expected - Actual) > Delta THEN
                Equals := FALSE;
                EXIT;
            END_IF
        END_FOR

        // Check for loop bailout
        IF NOT Equals THEN
            EXIT;
        END_IF
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2]),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2]),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();

    IF NOT SizeEquals THEN
        Message := Tc2_Standard.CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        //ExpectedString := 'SIZE = ';
        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d] (%dx%d)',
        //    arg1 := F_DINT(LowerBoundExpecteds[1]),
        //    arg2 := F_DINT(UpperBoundExpecteds[1]),
        //    arg3 := F_DINT(LowerBoundExpecteds[2]),
        //    arg4 := F_DINT(UpperBoundExpecteds[2]),
        //    arg5 := F_DINT(SizeOfExpecteds[1]),
        //    arg6 := F_DINT(SizeOfExpecteds[2]),
        //    sOut => ExpectedString);
		ExpectedString := 'SIZE = [';		 
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');

        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d] (%dx%d)',
        //    arg1 := F_DINT(LowerBoundActuals[1]),
        //    arg2 := F_DINT(UpperBoundActuals[1]),
        //    arg3 := F_DINT(LowerBoundActuals[2]),
        //    arg4 := F_DINT(UpperBoundActuals[2]),
        //    arg5 := F_DINT(SizeOfActuals[1]),
        //    arg6 := F_DINT(SizeOfActuals[2]),
        //    sOut => ActualString);
		ActualString := 'SIZE = [';		 
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ')');
    ELSE       
		//FormatString(
        //    sFormat := 'ARRAY[%d,%d] = %s',
        //    arg1 := F_DINT(ExpectedArrayIndex[1]),
        //    arg2 := F_DINT(ExpectedArrayIndex[2]),
        //    arg3 := F_STRING(LREAL_TO_STRING(Expected)),
        //   sOut => ExpectedString);
		ExpectedString := 'ARRAY[';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));	
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expected));
		
        //FormatString(
        //    sFormat := 'ARRAY[%d,%d] = %s',
        //    arg1 := F_DINT(ActualArrayIndex[1]),
        //    arg2 := F_DINT(ActualArrayIndex[2]),
        //    arg3 := F_STRING(LREAL_TO_STRING(Actual)),
        //    sOut => ActualString);
		ActualString := 'ARRAY[';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
		ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actual));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArray2dEquals_REAL" Id="{dc3b5666-7b5a-49ae-9837-cbb9bedd911a}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArray2dEquals_REAL
VAR_IN_OUT
    Expecteds : ARRAY[*,*] OF REAL; // REAL 2d array with expected values
    Actuals : ARRAY[*,*] OF REAL; // REAL 2d array with actual values
END_VAR
VAR_INPUT
    Delta : REAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    DimensionIndex : USINT; // Index when looping through Dimensions
    LowerBoundExpecteds : ARRAY[1..2] OF DINT; // Lower bounds of Expecteds array in each dimension
    UpperBoundExpecteds : ARRAY[1..2] OF DINT; // Upper bounds of Expecteds array in each dimension
    LowerBoundActuals : ARRAY[1..2] OF DINT; // Lower bounds of Actuals array in each dimension
    UpperBoundActuals : ARRAY[1..2] OF DINT; // Upper bounds of Actuals array in each dimension
    SizeOfExpecteds : ARRAY[1..2] OF DINT; // Size of Expecteds array in each dimension
    SizeOfActuals : ARRAY[1..2] OF DINT; // Size of Actuals array in each dimension
    Offset : ARRAY[1..2] OF DINT; // Current Array index offsets from Lower Bound in each dimension
    ExpectedArrayIndex : ARRAY[1..2] OF DINT; // Array of current Expected array indexes when looping through arrays
    ActualArrayIndex : ARRAY[1..2] OF DINT; // Array of current Actual array indexes when looping through arrays
    Expected : REAL; // Single expected value
    Actual : REAL; // Single actual value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter, 
   so they can't be called in a dimension-based loop.
   Thus we copy the ARRAY dimensions into arrays which accept variable indexes *)
LowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);
UpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);
LowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);
UpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);
LowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);
UpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);
LowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);
UpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);

FOR DimensionIndex := 1 TO 2 DO
    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;
    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;

    IF SizeOfExpecteds[DimensionIndex] <> SizeOfActuals[DimensionIndex] THEN
        Equals := FALSE;
        SizeEquals := FALSE;
    END_IF
END_FOR

IF SizeEquals THEN
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes in each dimension, which needs to be taken into account. *)
    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1
        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2
            // Update index variables
            FOR DimensionIndex := 1 TO 2 DO
                ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];
                ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];
            END_FOR

            // Get array element values
            Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2]];
            Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2]]; 

            IF ABS(Expected - Actual) > Delta THEN
                Equals := FALSE;
                EXIT;
            END_IF
        END_FOR

        // Check for loop bailout
        IF NOT Equals THEN
            EXIT;
        END_IF
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2]),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2]),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();

    IF NOT SizeEquals THEN
        Message := Tc2_Standard.CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        //ExpectedString := 'SIZE = ';
        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d] (%dx%d)',
        //    arg1 := F_DINT(LowerBoundExpecteds[1]),
        //    arg2 := F_DINT(UpperBoundExpecteds[1]),
        //    arg3 := F_DINT(LowerBoundExpecteds[2]),
        //    arg4 := F_DINT(UpperBoundExpecteds[2]),
        //    arg5 := F_DINT(SizeOfExpecteds[1]),
        //    arg6 := F_DINT(SizeOfExpecteds[2]),
        //    sOut => ExpectedString);
		ExpectedString := 'SIZE = [';		 
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');		

        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d] (%dx%d)',
        //    arg1 := F_DINT(LowerBoundActuals[1]),
        //    arg2 := F_DINT(UpperBoundActuals[1]),
        //    arg3 := F_DINT(LowerBoundActuals[2]),
        //    arg4 := F_DINT(UpperBoundActuals[2]),
        //    arg5 := F_DINT(SizeOfActuals[1]),
        //    arg6 := F_DINT(SizeOfActuals[2]),
        //    sOut => ActualString);
		ActualString := 'SIZE = [';		 
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ')');	   
	   
    ELSE
        //ExpectedValueString := REAL_TO_STRING(Expected);
        //ActualValueString := REAL_TO_STRING(Actual);
        //FormatString( 
        //    sFormat := 'ARRAY[%d,%d] = %s',
        //    arg1 := F_DINT(ExpectedArrayIndex[1]),
        //    arg2 := F_DINT(ExpectedArrayIndex[2]),
        //    arg3 := F_STRING(ExpectedValueString),
        //    sOut => ExpectedString);
		ExpectedString := 'ARRAY[';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));	
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expected));	   

        //FormatString( 
        //    sFormat := 'ARRAY[%d,%d] = %s',
        //    arg1 := F_DINT(ActualArrayIndex[1]),
        //    arg2 := F_DINT(ActualArrayIndex[2]),
        //    arg3 := F_STRING(ActualValueString),
        //    sOut => ActualString);
		ActualString := 'ARRAY[';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
		ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actual));	   
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArray3dEquals_LREAL" Id="{251da4d5-4df8-4eed-b154-a479323eb0d5}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArray3dEquals_LREAL
VAR_IN_OUT
    Expecteds : ARRAY[*,*,*] OF LREAL; // LREAL 3d array with expected values
    Actuals : ARRAY[*,*,*] OF LREAL; // LREAL 3d array with actual values
END_VAR
VAR_INPUT
    Delta : LREAL;  // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    DimensionIndex : USINT;  // Index when looping through Dimensions
    LowerBoundExpecteds : ARRAY[1..3] OF DINT; // Lower bounds of Expecteds array in each dimension
    UpperBoundExpecteds : ARRAY[1..3] OF DINT; // Upper bounds of Expecteds array in each dimension
    LowerBoundActuals : ARRAY[1..3] OF DINT; // Lower bounds of Actuals array in each dimension
    UpperBoundActuals : ARRAY[1..3] OF DINT; // Upper bounds of Actuals array in each dimension
    SizeOfExpecteds : ARRAY[1..3] OF DINT; // Size of Expecteds array in each dimension
    SizeOfActuals : ARRAY[1..3] OF DINT; // Size of Actuals array in each dimension
    Offset : ARRAY[1..3] OF DINT; // Current Array index offsets from Lower Bound in each dimension
    ExpectedArrayIndex : ARRAY[1..3] OF DINT; // Array of current Expected array indexes when looping through arrays
    ActualArrayIndex : ARRAY[1..3] OF DINT; // Array of current Actual array indexes when looping through arrays
    Expected : LREAL; // Single expected value
    Actual : LREAL; // Single actual value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,
   so they can't be called in a dimension-based loop.
   Thus we copy the array dimensions into arrays which accept variable indexes *)
LowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);
UpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);
LowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);
UpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);
LowerBoundExpecteds[3] := LOWER_BOUND(Expecteds, 3);
UpperBoundExpecteds[3] := UPPER_BOUND(Expecteds, 3);
LowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);
UpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);
LowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);
UpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);
LowerBoundActuals[3] := LOWER_BOUND(Actuals, 3);
UpperBoundActuals[3] := UPPER_BOUND(Actuals, 3);

FOR DimensionIndex := 1 TO 3 DO
    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;
    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;

    IF SizeOfExpecteds[DimensionIndex] <> SizeOfActuals[DimensionIndex] THEN
        Equals := FALSE;
        SizeEquals := FALSE;
    END_IF
END_FOR

IF SizeEquals THEN
    (* Even though we know that both arrays are equal in size, the three arrays can start at three completely different
       indexes in each dimension, which needs to be taken into account. *)
    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1
        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2
            FOR Offset[3] := 0 TO SizeOfExpecteds[3] - 1 DO // Iterate Dimension 3
                // Update index variables
                FOR DimensionIndex := 1 TO 3 DO
                    ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];
                    ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];
                END_FOR

                // Get array element values
                Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2], ExpectedArrayIndex[3]];
                Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2], ActualArrayIndex[3]]; 

                IF ABS(Expected - Actual) > Delta THEN
                    Equals := FALSE;
                    EXIT;
                END_IF
            END_FOR

            // Check for loop bailout
            IF NOT Equals THEN
                EXIT;
            END_IF
        END_FOR

        // Check for loop bailout
        IF NOT Equals THEN
            EXIT;
        END_IF
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2] * SizeOfExpecteds[3]),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2] * SizeOfActuals[3]),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();

    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        //ExpectedString := 'SIZE = ';
        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d,%d..%d] (%dx%dx%d)',
        //    arg1 := F_DINT(LowerBoundExpecteds[1]),
        //    arg2 := F_DINT(UpperBoundExpecteds[1]),
        //    arg3 := F_DINT(LowerBoundExpecteds[2]),
        //    arg4 := F_DINT(UpperBoundExpecteds[2]),
        //    arg5 := F_DINT(LowerBoundExpecteds[3]),
        //    arg6 := F_DINT(UpperBoundExpecteds[3]),
        //    arg7 := F_DINT(SizeOfExpecteds[1]),
        //    arg8 := F_DINT(SizeOfExpecteds[2]),
        //    arg9 := F_DINT(SizeOfExpecteds[3]),
        //    sOut => ExpectedString);
		ExpectedString := 'SIZE = [';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[3]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[3]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[3]));	
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');

        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d,%d..%d] (%dx%dx%d)',
        //    arg1 := F_DINT(LowerBoundActuals[1]),
        //    arg2 := F_DINT(UpperBoundActuals[1]),
        //    arg3 := F_DINT(LowerBoundActuals[2]),
        //    arg4 := F_DINT(UpperBoundActuals[2]),
        //    arg5 := F_DINT(LowerBoundActuals[3]),
        //    arg6 := F_DINT(UpperBoundActuals[3]),
        //    arg7 := F_DINT(SizeOfActuals[1]),
        //    arg8 := F_DINT(SizeOfActuals[2]),
        //    arg9 := F_DINT(SizeOfActuals[3]),
        //    sOut => ActualString);
		ActualString := 'SIZE = [';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[3]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[3]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[3]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := ')');		
    ELSE
       //ExpectedValueString := LREAL_TO_STRING(Expected);
        //ActualValueString := LREAL_TO_STRING(Actual);
        //FormatString( 
        //    sFormat := 'ARRAY[%d,%d,%d] = %s',
        //    arg1 := F_DINT(ExpectedArrayIndex[1]),
        //    arg2 := F_DINT(ExpectedArrayIndex[2]),
        //    arg3 := F_DINT(ExpectedArrayIndex[3]),
        //    arg4 := F_STRING(ExpectedValueString),
        //    sOut => ExpectedString);
		ExpectedString := 'ARRAY[';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[3]));		
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expected) );		

        // FormatString( 
        //     sFormat := 'ARRAY[%d,%d,%d] = %s',
        //     arg1 := F_DINT(ActualArrayIndex[1]),
        //     arg2 := F_DINT(ActualArrayIndex[2]),
        //     arg3 := F_DINT(ActualArrayIndex[3]),
        //     arg4 := F_STRING(ActualValueString),
        //     sOut => ActualString);	
		ActualString := 'ARRAY[';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[3]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
		ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actual));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArray3dEquals_REAL" Id="{0dc8fccf-4b9a-4206-8d9f-212f576edb04}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArray3dEquals_REAL
VAR_IN_OUT
    Expecteds : ARRAY[*,*,*] OF REAL; // REAL 3d array with expected values
    Actuals : ARRAY[*,*,*] OF REAL; // REAL 3d array with actual values
END_VAR
VAR_INPUT
    Delta : REAL; // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    DimensionIndex : USINT;  // Index when looping through Dimensions
    LowerBoundExpecteds : ARRAY[1..3] OF DINT; // Lower bounds of Expecteds array in each dimension
    UpperBoundExpecteds : ARRAY[1..3] OF DINT; // Upper bounds of Expecteds array in each dimension
    LowerBoundActuals : ARRAY[1..3] OF DINT; // Lower bounds of Actuals array in each dimension
    UpperBoundActuals : ARRAY[1..3] OF DINT; // Upper bounds of Actuals array in each dimension
    SizeOfExpecteds : ARRAY[1..3] OF DINT; // Size of Expecteds array in each dimension
    SizeOfActuals : ARRAY[1..3] OF DINT; // Size of Actuals array in each dimension
    Offset : ARRAY[1..3] OF DINT; // Current Array index offsets from Lower Bound in each dimension
    ExpectedArrayIndex : ARRAY[1..3] OF DINT; // Array of current Expected array indexes when looping through arrays
    ActualArrayIndex : ARRAY[1..3] OF DINT; // Array of current Actual array indexes when looping through arrays
    Expected : REAL; // Single expected value
    Actual : REAL; // Single actual value
    ExpectedValueString : Tc2_System.T_MaxString;
    ActualValueString : Tc2_System.T_MaxString;
    FormatString : Tc2_Utilities.FB_FormatString; // String formatter for output messages
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

(* UPPER_BOUND and LOWER_BOUND require literals for their second parameter,
   so they can't be called in a dimension-based loop.
   Thus we copy the array dimensions into arrays which accept variable indexes *)
LowerBoundExpecteds[1] := LOWER_BOUND(Expecteds, 1);
UpperBoundExpecteds[1] := UPPER_BOUND(Expecteds, 1);
LowerBoundExpecteds[2] := LOWER_BOUND(Expecteds, 2);
UpperBoundExpecteds[2] := UPPER_BOUND(Expecteds, 2);
LowerBoundExpecteds[3] := LOWER_BOUND(Expecteds, 3);
UpperBoundExpecteds[3] := UPPER_BOUND(Expecteds, 3);
LowerBoundActuals[1] := LOWER_BOUND(Actuals, 1);
UpperBoundActuals[1] := UPPER_BOUND(Actuals, 1);
LowerBoundActuals[2] := LOWER_BOUND(Actuals, 2);
UpperBoundActuals[2] := UPPER_BOUND(Actuals, 2);
LowerBoundActuals[3] := LOWER_BOUND(Actuals, 3);
UpperBoundActuals[3] := UPPER_BOUND(Actuals, 3);

FOR DimensionIndex := 1 TO 3 DO
    SizeOfExpecteds[DimensionIndex] := ABS(UpperBoundExpecteds[DimensionIndex] - LowerBoundExpecteds[DimensionIndex]) + 1;
    SizeOfActuals[DimensionIndex] := ABS(UpperBoundActuals[DimensionIndex] - LowerBoundActuals[DimensionIndex]) + 1;

    IF SizeOfExpecteds[DimensionIndex] <> SizeOfActuals[DimensionIndex] THEN
        Equals := FALSE;
        SizeEquals := FALSE;
    END_IF
END_FOR

IF SizeEquals THEN
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes in each dimension, which needs to be taken into account. *)
    FOR Offset[1] := 0 TO SizeOfExpecteds[1] - 1 DO // Iterate Dimension 1
        FOR Offset[2] := 0 TO SizeOfExpecteds[2] - 1 DO // Iterate Dimension 2
            FOR Offset[3] := 0 TO SizeOfExpecteds[3] - 1 DO // Iterate Dimension 3
                // Update index variables
                FOR DimensionIndex := 1 TO 3 DO
                    ExpectedArrayIndex[DimensionIndex] := LowerBoundExpecteds[DimensionIndex] + Offset[DimensionIndex];
                    ActualArrayIndex[DimensionIndex] := LowerBoundActuals[DimensionIndex] + Offset[DimensionIndex];
                END_FOR

                // Get array element values
                Expected := Expecteds[ExpectedArrayIndex[1], ExpectedArrayIndex[2], ExpectedArrayIndex[3]];
                Actual := Actuals[ActualArrayIndex[1], ActualArrayIndex[2], ActualArrayIndex[3]]; 

                IF ABS(Expected - Actual) > Delta THEN
                    Equals := FALSE;
                    EXIT;
                END_IF
            END_FOR

            // Check for loop bailout
            IF NOT Equals THEN
                EXIT;
            END_IF
        END_FOR

        // Check for loop bailout
        IF NOT Equals THEN
            EXIT;
        END_IF
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds[1] * SizeOfExpecteds[2] * SizeOfExpecteds[3]),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals[1] * SizeOfActuals[2] * SizeOfActuals[3]),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();

    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        //FormatString(
        //    sFormat := 'SIZE = [%d..%d,%d..%d,%d..%d] (%dx%dx%d)',
        //    arg1 := F_DINT(LowerBoundExpecteds[1]),
        //    arg2 := F_DINT(UpperBoundExpecteds[1]),
        //    arg3 := F_DINT(LowerBoundExpecteds[2]),
        //    arg4 := F_DINT(UpperBoundExpecteds[2]),
        //    arg5 := F_DINT(LowerBoundExpecteds[3]),
        //    arg6 := F_DINT(UpperBoundExpecteds[3]),
        //    arg7 := F_DINT(SizeOfExpecteds[1]),
        //    arg8 := F_DINT(SizeOfExpecteds[2]),
        //    arg9 := F_DINT(SizeOfExpecteds[3]),
        //    sOut => ExpectedString);
		ExpectedString := 'SIZE = [';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(LowerBoundExpecteds[3]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '..');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(UpperBoundExpecteds[3]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] (');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := 'x');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds[3]));	
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ')');
		
        //FormatString( 
        //    sFormat := 'SIZE = [%d..%d,%d..%d,%d..%d] (%dx%dx%d)',
        //    arg1 := F_DINT(LowerBoundActuals[1]),
        //    arg2 := F_DINT(UpperBoundActuals[1]),
        //    arg3 := F_DINT(LowerBoundActuals[2]),
        //    arg4 := F_DINT(UpperBoundActuals[2]),
        //    arg5 := F_DINT(LowerBoundActuals[3]),
        //    arg6 := F_DINT(UpperBoundActuals[3]),
        //    arg7 := F_DINT(SizeOfActuals[1]),
        //    arg8 := F_DINT(SizeOfActuals[2]),
        //    arg9 := F_DINT(SizeOfActuals[3]),
        //    sOut => ActualString);
		ActualString := 'SIZE = [';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(LowerBoundActuals[3]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '..');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(UpperBoundActuals[3]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] (');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := 'x');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals[3]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := ')');		
    ELSE
        //ExpectedValueString := REAL_TO_STRING(Expected);
        //ActualValueString := REAL_TO_STRING(Actual);
        //FormatString( 
        //    sFormat := 'ARRAY[%d,%d,%d] = %s',
        //    arg1 := F_DINT(ExpectedArrayIndex[1]),
        //    arg2 := F_DINT(ExpectedArrayIndex[2]),
        //    arg3 := F_DINT(ExpectedArrayIndex[3]),
        //    arg4 := F_STRING(ExpectedValueString),
        //    sOut => ExpectedString);
		ExpectedString := 'ARRAY[';
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[1]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[2]));
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ',');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedArrayIndex[3]));		
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
		ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expected) );			

        //FormatString( 
        //    sFormat := 'ARRAY[%d,%d,%d] = %s',
        //    arg1 := F_DINT(ActualArrayIndex[1]),
        //    arg2 := F_DINT(ActualArrayIndex[2]),
        //    arg3 := F_DINT(ActualArrayIndex[3]),
        //    arg4 := F_STRING(ActualValueString),
        //    sOut => ActualString);
		ActualString := 'ARRAY[';
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[1]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[2]));
		ActualString := CONCAT(STR1 := ActualString, STR2 := ',');
		ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualArrayIndex[3]));	
		ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
		ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actual));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_BOOL" Id="{3d4059ab-c241-4859-9a9f-090cab6db606}">
      <Declaration><![CDATA[(*
    Asserts that two BOOL arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_BOOL
VAR_IN_OUT
    Expecteds : ARRAY[*] OF BOOL; // BOOL array with expected values
    Actuals : ARRAY[*] OF BOOL; // BOOL array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_BOOL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := BOOL_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := BOOL_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_BYTE" Id="{375a5287-a3e9-4833-ac17-bab8f3f0fdc9}">
      <Declaration><![CDATA[(*
    Asserts that two BYTE arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_BYTE
VAR_IN_OUT
    Expecteds : ARRAY[*] OF BYTE; // BYTE array with expected values
    Actuals : ARRAY[*] OF BYTE; // BYTE array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedByteString : STRING;
    ActualByteString : STRING;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_BYTE,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedByteString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                  STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Expecteds[ExpectedsIndex],
                                                                                       iPrecision := 2,
                                                                                       bLoCase := FALSE));
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedByteString);

        ActualByteString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Actuals[ActualsIndex],
                                                                                     iPrecision := 2,
                                                                                     bLoCase := FALSE));
        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualByteString);
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_DINT" Id="{4f0d9b20-0c78-467d-a52a-6badbd5d37cc}">
      <Declaration><![CDATA[(*
    Asserts that two DINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_DINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF DINT; // DINT array with expected values
    Actuals : ARRAY[*] OF DINT; // DINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_DINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_DWORD" Id="{eec9d02d-95a1-4885-9906-ad4b2d0f4cab}">
      <Declaration><![CDATA[(*
    Asserts that two DWORD arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_DWORD
VAR_IN_OUT
    Expecteds : ARRAY[*] OF DWORD; // DWORD array with expected values
    Actuals : ARRAY[*] OF DWORD; // DWORD array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedDWordString : STRING;
    ActualDWordString : STRING;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_DWORD,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                  STR2 := Tc2_Utilities.DWORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],
                                                                                        iPrecision := 8,
                                                                                        bLoCase := FALSE));
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedDWordString);

        ActualDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                STR2 := Tc2_Utilities.DWORD_TO_HEXSTR(in := Actuals[ActualsIndex],
                                                                                      iPrecision := 8,
                                                                                      bLoCase := FALSE));
        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualDWordString);
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_INT" Id="{d54cf111-a7e7-4f51-bdf4-9853e055f62d}">
      <Declaration><![CDATA[(*
    Asserts that two INT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_INT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF INT; // INT array with expected values
    Actuals : ARRAY[*] OF INT; // INT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_INT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_INT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := INT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := INT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_LINT" Id="{d7e53e6b-caed-4867-9ef5-3ccb7ae16bf8}">
      <Declaration><![CDATA[(*
    Asserts that two LINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_LINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF LINT; // LINT array with expected values
    Actuals : ARRAY[*] OF LINT; // LINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := LINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_LREAL" Id="{fbc23ff0-cdf6-43f2-82cd-e6f3a7903664}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArrayEquals_LREAL
VAR_IN_OUT
    Expecteds : ARRAY[*] OF LREAL; // LREAL array with expected values
    Actuals : ARRAY[*] OF LREAL; // LREAL array with actual values
END_VAR
VAR_INPUT
    Delta : LREAL;  // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF ABS(Expecteds[ExpectedsIndex] - Actuals[ActualsIndex]) > Delta THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LREAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := LREAL_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := LREAL_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_LWORD" Id="{7bc0c786-fccc-46e3-b38f-2013c44bfcb0}">
      <Declaration><![CDATA[(*
    Asserts that two LWORD arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_LWORD
VAR_IN_OUT
    Expecteds : ARRAY[*] OF LWORD; // LWORD array with expected values
    Actuals : ARRAY[*] OF LWORD; // LWORD array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedDWordString : STRING;
    ActualDWordString : STRING;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_LWORD,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                  STR2 := Tc2_Utilities.LWORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],
                                                                                        iPrecision := 16,
                                                                                        bLoCase := FALSE));
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedDWordString);

        ActualDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                STR2 := Tc2_Utilities.LWORD_TO_HEXSTR(in := Actuals[ActualsIndex],
                                                                                      iPrecision := 16,
                                                                                      bLoCase := FALSE));
        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualDWordString);
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_REAL" Id="{c42ec40e-0859-4258-a3b2-11b258dab324}">
      <Declaration><![CDATA[METHOD PUBLIC AssertArrayEquals_REAL
VAR_IN_OUT
    Expecteds : ARRAY[*] OF REAL; // REAL array with expected values
    Actuals : ARRAY[*] OF REAL; // REAL array with actual values
END_VAR
VAR_INPUT
    Delta : REAL;  // The maximum delta between the value of expected and actual for which both numbers are still considered equal, proportional to the Expected value in that array cell
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF ABS(Expecteds[ExpectedsIndex] - Actuals[ActualsIndex]) > Delta THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_REAL,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := REAL_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := REAL_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_SINT" Id="{133c577e-0641-4157-b42b-46dbf29f788e}">
      <Declaration><![CDATA[(*
    Asserts that two SINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_SINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF SINT; // SINT array with expected values
    Actuals : ARRAY[*] OF SINT; // SINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_SINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := SINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := SINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_UDINT" Id="{5f690331-57e2-4ea1-b1d7-ab65b52dc848}">
      <Declaration><![CDATA[(*
    Asserts that two UDINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_UDINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF UDINT; // UDINT array with expected values
    Actuals : ARRAY[*] OF UDINT; // UDINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_UDINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := UDINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := UDINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_UINT" Id="{358571ac-0a0d-4e71-8097-c7943f718fce}">
      <Declaration><![CDATA[(*
    Asserts that two UINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_UINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF UINT; // UINT array with expected values
    Actuals : ARRAY[*] OF UINT; // UINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_UINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := UINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := UINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_ULINT" Id="{916529a0-57b3-4947-a5b8-e7b9ff17f35f}">
      <Declaration><![CDATA[(*
    Asserts that two ULINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_ULINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF ULINT; // ULINT array with expected values
    Actuals : ARRAY[*] OF ULINT; // ULINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_ULINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ULINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := ULINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_USINT" Id="{b3215098-2f26-48bf-a7e4-ee1a0803a968}">
      <Declaration><![CDATA[(*
    Asserts that two USINT arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_USINT
VAR_IN_OUT
    Expecteds : ARRAY[*] OF USINT; // USINT array with expected values
    Actuals : ARRAY[*] OF USINT; // USINT array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_USINT,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := USINT_TO_STRING(Expecteds[ExpectedsIndex]));

        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := USINT_TO_STRING(Actuals[ActualsIndex]));
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertArrayEquals_WORD" Id="{16eada18-ce2b-459d-a8d9-277e84766935}">
      <Declaration><![CDATA[(*
    Asserts that two WORD arrays are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertArrayEquals_WORD
VAR_IN_OUT
    Expecteds : ARRAY[*] OF WORD; // WORD array with expected values
    Actuals : ARRAY[*] OF WORD; // WORD array with actual values
END_VAR
VAR_INPUT
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Equals : BOOL := TRUE;
    SizeEquals : BOOL := TRUE;
    Index : DINT;
    ExpectedString : STRING;
    ActualString : STRING;
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
    SizeOfExpecteds : DINT;
    SizeOfActuals : DINT;
    ExpectedDWordString : STRING;
    ActualDWordString : STRING;
    ExpectedsIndex : DINT;
    ActualsIndex : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(FindTestSuiteInstancePath());

SizeOfExpecteds := ABS(UPPER_BOUND(Expecteds, 1) - LOWER_BOUND(Expecteds, 1)) + 1;
SizeOfActuals := ABS(UPPER_BOUND(Actuals, 1) - LOWER_BOUND(Actuals, 1)) + 1;

IF SizeOfExpecteds <> SizeOfActuals THEN
    Equals := FALSE;
    SizeEquals := FALSE;
ELSE
    (* Even though we know that both arrays are equal in size, the two arrays can start at two completely different
       indexes, which needs to be taken into account for. *)
    ExpectedsIndex := LOWER_BOUND(Expecteds, 1); // The start position for the expecteds
    ActualsIndex := LOWER_BOUND(Actuals, 1); // The start position for the actuals
    FOR Index := 1 TO SizeOfExpecteds BY 1 DO
        IF Expecteds[ExpectedsIndex] <> Actuals[ActualsIndex] THEN
            Equals := FALSE;
            EXIT;
        END_IF
        ExpectedsIndex := ExpectedsIndex + 1;
        ActualsIndex := ActualsIndex + 1;
    END_FOR
END_IF

IF NOT Equals THEN
    AssertArrayResult.ReportResult(ExpectedsSize := DINT_TO_UDINT(SizeOfExpecteds),
                                   ExpectedsTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,
                                   ActualsSize := DINT_TO_UDINT(SizeOfActuals),
                                   ActualsTypeClass := IBaseLibrary.TypeClass.TYPE_WORD,
                                   Message := Message,
                                   TestInstancePath := TestInstancePath,
                                   AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND NOT Equals THEN
    SetTestFailed();
    
    IF NOT SizeEquals THEN
        Message := CONCAT(STR1 := Message, STR2 := ', size of arrays not matching.');
        ExpectedString := 'SIZE = ';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(SizeOfExpecteds));
        ActualString := 'SIZE = ';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(SizeOfActuals));
    ELSE
        ExpectedDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                  STR2 := Tc2_Utilities.WORD_TO_HEXSTR(in := Expecteds[ExpectedsIndex],
                                                                                       iPrecision := 4,
                                                                                       bLoCase := FALSE));
        ExpectedString := 'ARRAY[';
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := DINT_TO_STRING(ExpectedsIndex));
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := '] = ');
        ExpectedString := CONCAT(STR1 := ExpectedString, STR2 := ExpectedDWordString);

        ActualDWordString := Tc2_Standard.CONCAT(STR1 := '0x',
                                                STR2 := Tc2_Utilities.WORD_TO_HEXSTR(in := Actuals[ActualsIndex],
                                                                                     iPrecision := 4,
                                                                                     bLoCase := FALSE));
        ActualString := 'ARRAY[';
        ActualString := CONCAT(STR1 := ActualString, STR2 := DINT_TO_STRING(ActualsIndex));
        ActualString := CONCAT(STR1 := ActualString, STR2 := '] = ');
        ActualString := CONCAT(STR1 := ActualString, STR2 := ActualDWordString);
    END_IF

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedString,
                                            Actual := ActualString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals" Id="{092092ee-35b6-45cc-a1ac-e428e5d747ba}">
      <Declaration><![CDATA[(*
    Asserts that two objects (of any type) are equal. If they are not, an assertion error is created.
    For REAL and LREAL it's recommended to use the AssertEquals_REAL or AssertEquals_LREAL respectively
    as these give the possibility to specify a delta between the expected and actual value.
*)
METHOD PUBLIC AssertEquals
VAR_INPUT
    Expected : ANY; // Expected value
    Actual : ANY; // The value to check against expected
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    Count : DINT;
    ExpectedDataString : STRING(80);
    ActualDataString : STRING(80);
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
    AnyComparator : FB_AnyComparator;

    boolExpected : BOOL;
    boolActual : BOOL;
    byteExpected : BYTE;
    byteActual : BYTE;
    dateExpected : DATE;
    dateActual : DATE;
    dateAndTimeExpected : DATE_AND_TIME;
    dateAndTimeActual : DATE_AND_TIME;
    dintExpected : DINT;
    dintActual : DINT;
    dwordExpected : DWORD;
    dwordActual : DWORD;
    intExpected : INT;
    intActual : INT;
    lintExpected : LINT;
    lintActual : LINT;
    lrealExpected : LREAL;
    lrealActual : LREAL;
    ltimeExpected : LTIME;
    ltimeActual : LTIME;
    lwordExpected : LWORD;
    lwordActual : LWORD;
    realExpected : REAL;
    realActual : REAL;
    sintExpected : SINT;
    sintActual : SINT;
    stringExpected : Tc2_System.T_MaxString;
    stringActual : Tc2_System.T_MaxString;
    timeExpected : TIME;
    timeActual : TIME;
    timeOfDayExpected : TIME_OF_DAY;
    timeOfDayActual : TIME_OF_DAY;
    udintExpected : UDINT;
    udintActual : UDINT;
    uintExpected : UINT;
    uintActual : UINT;
    ulintExpected : ULINT;
    ulintActual : ULINT;
    usintExpected : USINT;
    usintActual : USINT;
    wordExpected : WORD;
    wordActual : WORD;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

AnyComparator(AnyValueOne := Expected,
              AnyValueTwo := Actual);

(* First check whether the input data are any of the standard data types that are supported by TcUnit.
   In this case call the standard Assert-methods for that data. But before doing that we need to make sure
   that both the expected and actual:
   - Have both the same data type
   - Both have the same data size
*)
IF NOT AnyComparator.DataTypesNotEquals AND NOT AnyComparator.DataSizeNotEquals THEN

    (* BOOL *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_BOOL THEN
        Tc2_System.MEMCPY(destAddr := ADR(boolExpected), srcAddr := Expected.pValue, n := SIZEOF(BOOL));
        Tc2_System.MEMCPY(destAddr := ADR(boolActual), srcAddr := Actual.pValue, n := SIZEOF(BOOL));
        AssertEquals_BOOL(Expected := boolExpected, Actual := boolActual, Message := Message);
        RETURN;
    END_IF

    (* BYTE *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_BYTE THEN
        Tc2_System.MEMCPY(destAddr := ADR(byteExpected), srcAddr := Expected.pValue, n := SIZEOF(BYTE));
        Tc2_System.MEMCPY(destAddr := ADR(byteActual), srcAddr := Actual.pValue, n := SIZEOF(BYTE));
        AssertEquals_BYTE(Expected := byteExpected, Actual := byteActual, Message := Message);
        RETURN;
    END_IF

    (* DATE *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DATE THEN
        Tc2_System.MEMCPY(destAddr := ADR(dateExpected), srcAddr := Expected.pValue, n := SIZEOF(DATE));
        Tc2_System.MEMCPY(destAddr := ADR(dateActual), srcAddr := Actual.pValue, n := SIZEOF(DATE));
        AssertEquals_DATE(Expected := dateExpected, Actual := dateActual, Message := Message);
        RETURN;
    END_IF

    (* DATE_AND_TIME *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DATEANDTIME THEN
        Tc2_System.MEMCPY(destAddr := ADR(dateAndTimeExpected), srcAddr := Expected.pValue, n := SIZEOF(DATE_AND_TIME));
        Tc2_System.MEMCPY(destAddr := ADR(dateAndTimeActual), srcAddr := Actual.pValue, n := SIZEOF(DATE_AND_TIME));
        AssertEquals_DATE_AND_TIME(Expected := dateAndTimeExpected, Actual := dateAndTimeActual, Message := Message);
        RETURN;
    END_IF

    (* DINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(dintExpected), srcAddr := Expected.pValue, n := SIZEOF(DINT));
        Tc2_System.MEMCPY(destAddr := ADR(dintActual), srcAddr := Actual.pValue, n := SIZEOF(DINT));
        AssertEquals_DINT(Expected := dintExpected, Actual := dintActual, Message := Message);
        RETURN;
    END_IF

    (* DWORD *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_DWORD THEN
        Tc2_System.MEMCPY(destAddr := ADR(dwordExpected), srcAddr := Expected.pValue, n := SIZEOF(DWORD));
        Tc2_System.MEMCPY(destAddr := ADR(dwordActual), srcAddr := Actual.pValue, n := SIZEOF(DWORD));
        AssertEquals_DWORD(Expected := dwordExpected, Actual := dwordActual, Message := Message);
        RETURN;
    END_IF

    (* INT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_INT THEN
        Tc2_System.MEMCPY(destAddr := ADR(intExpected), srcAddr := Expected.pValue, n := SIZEOF(INT));
        Tc2_System.MEMCPY(destAddr := ADR(intActual), srcAddr := Actual.pValue, n := SIZEOF(INT));
        AssertEquals_INT(Expected := intExpected, Actual := intActual, Message := Message);
        RETURN;
    END_IF

    (* LINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(lintExpected), srcAddr := Expected.pValue, n := SIZEOF(LINT));
        Tc2_System.MEMCPY(destAddr := ADR(lintActual), srcAddr := Actual.pValue, n := SIZEOF(LINT));
        AssertEquals_LINT(Expected := lintExpected, Actual := lintActual, Message := Message);
        RETURN;
    END_IF

    (* LREAL *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LREAL THEN
        Tc2_System.MEMCPY(destAddr := ADR(lrealExpected), srcAddr := Expected.pValue, n := SIZEOF(LREAL));
        Tc2_System.MEMCPY(destAddr := ADR(lrealActual), srcAddr := Actual.pValue, n := SIZEOF(LREAL));
        AssertEquals_LREAL(Expected := lrealExpected, Actual := lrealActual, Delta := 0.0, Message := Message);
        RETURN;
    END_IF

    (* LTIME *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LTIME THEN
        Tc2_System.MEMCPY(destAddr := ADR(ltimeExpected), srcAddr := Expected.pValue, n := SIZEOF(LTIME));
        Tc2_System.MEMCPY(destAddr := ADR(ltimeActual), srcAddr := Actual.pValue, n := SIZEOF(LTIME));
        AssertEquals_LTIME(Expected := ltimeExpected, Actual := ltimeActual, Message := Message);
        RETURN;
    END_IF

    (* LWORD *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_LWORD THEN
        Tc2_System.MEMCPY(destAddr := ADR(lwordExpected), srcAddr := Expected.pValue, n := SIZEOF(LWORD));
        Tc2_System.MEMCPY(destAddr := ADR(lwordActual), srcAddr := Actual.pValue, n := SIZEOF(LWORD));
        AssertEquals_LWORD(Expected := lwordExpected, Actual := lwordActual, Message := Message);
        RETURN;
    END_IF

    (* REAL *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_REAL THEN
        Tc2_System.MEMCPY(destAddr := ADR(realExpected), srcAddr := Expected.pValue, n := SIZEOF(REAL));
        Tc2_System.MEMCPY(destAddr := ADR(realActual), srcAddr := Actual.pValue, n := SIZEOF(REAL));
        AssertEquals_REAL(Expected := realExpected, Actual := realActual, Delta := 0.0, Message := Message);
        RETURN;
    END_IF

    (* SINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_SINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(sintExpected), srcAddr := Expected.pValue, n := SIZEOF(SINT));
        Tc2_System.MEMCPY(destAddr := ADR(sintActual), srcAddr := Actual.pValue, n := SIZEOF(SINT));
        AssertEquals_SINT(Expected := sintExpected, Actual := sintActual, Message := Message);
        RETURN;
    END_IF

    (* STRING *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_STRING THEN
        Tc2_System.MEMCPY(destAddr := ADR(stringExpected), srcAddr := Expected.pValue, n := DINT_TO_UDINT(Expected.diSize));
        Tc2_System.MEMCPY(destAddr := ADR(stringActual), srcAddr := Actual.pValue, n := DINT_TO_UDINT(Actual.diSize));
        AssertEquals_STRING(Expected := stringExpected, Actual := stringActual, Message := Message);
        RETURN;
    END_IF

    (* TIME *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_TIME THEN
        Tc2_System.MEMCPY(destAddr := ADR(timeExpected), srcAddr := Expected.pValue, n := SIZEOF(TIME));
        Tc2_System.MEMCPY(destAddr := ADR(timeActual), srcAddr := Actual.pValue, n := SIZEOF(TIME));
        AssertEquals_TIME(Expected := timeExpected, Actual := timeActual, Message := Message);
        RETURN;
    END_IF

    (* TIME_OF_DAY *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_TIMEOFDAY THEN
        Tc2_System.MEMCPY(destAddr := ADR(timeOfDayExpected), srcAddr := Expected.pValue, n := SIZEOF(TIME_OF_DAY));
        Tc2_System.MEMCPY(destAddr := ADR(timeOfDayActual), srcAddr := Actual.pValue, n := SIZEOF(TIME_OF_DAY));
        AssertEquals_TIME_OF_DAY(Expected := timeOfDayExpected, Actual := timeOfDayActual, Message := Message);
        RETURN;
    END_IF

    (* UDINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_UDINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(udintExpected), srcAddr := Expected.pValue, n := SIZEOF(UDINT));
        Tc2_System.MEMCPY(destAddr := ADR(udintActual), srcAddr := Actual.pValue, n := SIZEOF(UDINT));
        AssertEquals_UDINT(Expected := udintExpected, Actual := udintActual, Message := Message);
        RETURN;
    END_IF

    (* UINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_UINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(uintExpected), srcAddr := Expected.pValue, n := SIZEOF(UINT));
        Tc2_System.MEMCPY(destAddr := ADR(uintActual), srcAddr := Actual.pValue, n := SIZEOF(UINT));
        AssertEquals_UINT(Expected := uintExpected, Actual := uintActual, Message := Message);
        RETURN;
    END_IF

    (* ULINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_ULINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(ulintExpected), srcAddr := Expected.pValue, n := SIZEOF(ULINT));
        Tc2_System.MEMCPY(destAddr := ADR(ulintActual), srcAddr := Actual.pValue, n := SIZEOF(ULINT));
        AssertEquals_ULINT(Expected := ulintExpected, Actual := ulintActual, Message := Message);
        RETURN;
    END_IF

    (* USINT *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_USINT THEN
        Tc2_System.MEMCPY(destAddr := ADR(usintExpected), srcAddr := Expected.pValue, n := SIZEOF(USINT));
        Tc2_System.MEMCPY(destAddr := ADR(usintActual), srcAddr := Actual.pValue, n := SIZEOF(USINT));
        AssertEquals_USINT(Expected := usintExpected, Actual := usintActual, Message := Message);
        RETURN;
    END_IF

    (* WORD *)
    IF UDINT_TO_INT(Expected.TypeClass) = IBaseLibrary.TypeClass.TYPE_WORD THEN
        Tc2_System.MEMCPY(destAddr := ADR(wordExpected), srcAddr := Expected.pValue, n := SIZEOF(WORD));
        Tc2_System.MEMCPY(destAddr := ADR(wordActual), srcAddr := Actual.pValue, n := SIZEOF(WORD));
        AssertEquals_WORD(Expected := wordExpected, Actual := wordActual, Message := Message);
        RETURN;
    END_IF

END_IF

(* If we've come to this row, it means that the data input is not any of the standard primitive data types, and thus
   we need to do special handling *)
TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF AnyComparator.DataTypesNotEquals THEN
    ExpectedDataString := Tc2_Standard.CONCAT(STR1 := '(Type class = ', STR2 := F_AnyTypeClassToString((Expected.TypeClass)));
    ExpectedDataString := Tc2_Standard.CONCAT(STR1 := ExpectedDataString, STR2 := ')');
    ActualDataString := Tc2_Standard.CONCAT(STR1 := '(Type class = ', STR2 := F_AnyTypeClassToString(Actual.TypeClass));
    ActualDataString := Tc2_Standard.CONCAT(STR1 := ActualDataString, STR2 := ')');
ELSIF AnyComparator.DataSizeNotEquals THEN
    ExpectedDataString := Tc2_Standard.CONCAT(STR1 := '(Data size = ', STR2 := DINT_TO_STRING(Expected.diSize));
    ExpectedDataString := Tc2_Standard.CONCAT(STR1 := ExpectedDataString, STR2 := ')');
    ActualDataString := Tc2_Standard.CONCAT(STR1 := '(Data size = ', STR2 := DINT_TO_STRING(Actual.diSize));
    ActualDataString := Tc2_Standard.CONCAT(STR1 := ActualDataString, STR2 := ')');
ELSIF AnyComparator.DataContentNotEquals THEN
    FOR Count := 0 TO MIN(Expected.diSize-1, 38) BY 1 DO // One byte will equal two characters (example: 255 = 0xff, 1 = 0x01)
        ExpectedDataString := Tc2_Standard.CONCAT(STR1 := ExpectedDataString,
                                                  STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Expected.pValue[Count],
                                                                                       iPrecision := 2,
                                                                                       bLoCase := FALSE));
    END_FOR
    ExpectedDataString := Tc2_Standard.CONCAT(STR1 := '0x', STR2 := ExpectedDataString);

    FOR Count := 0 TO MIN(Actual.diSize-1, 38) BY 1 DO // One byte will equal two characters (example: 255 = 0xff, 1 = 0x01)
        ActualDataString := Tc2_Standard.CONCAT(STR1 := ActualDataString,
                                                STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Actual.pValue[Count],
                                                                                     iPrecision := 2,
                                                                                     bLoCase := FALSE));
    END_FOR
    ActualDataString := Tc2_Standard.CONCAT(STR1 := '0x', STR2 := ActualDataString);
END_IF

IF (AnyComparator.DataTypesNotEquals OR AnyComparator.DataSizeNotEquals OR AnyComparator.DataContentNotEquals) THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND (AnyComparator.DataTypesNotEquals OR AnyComparator.DataSizeNotEquals OR AnyComparator.DataContentNotEquals) THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := ExpectedDataString,
                                            Actual := ActualDataString,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_BOOL" Id="{0c41b405-ea35-4450-93cc-7c3349bdf754}">
      <Declaration><![CDATA[(*
    Asserts that two BOOLs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_BOOL
VAR_INPUT
    Expected : BOOL; // BOOL expected value
    Actual : BOOL; // BOOL actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF                               

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := BOOL_TO_STRING(Expected),
                                            Actual := BOOL_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_BYTE" Id="{c039f3f1-9c41-4f5e-93a3-393ce160979a}">
      <Declaration><![CDATA[(*
    Asserts that two BYTEs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_BYTE
VAR_INPUT
    Expected : BYTE; // BYTE expected value
    Actual : BYTE; // BYTE actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := Tc2_Standard.CONCAT(
                                                       STR1 := '0x',
                                                       STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Expected,
                                                                                            iPrecision := 2,
                                                                                            bLoCase := FALSE)),
                                            Actual := Tc2_Standard.CONCAT(
                                                       STR1 := '0x',
                                                       STR2 := Tc2_Utilities.BYTE_TO_HEXSTR(in := Actual,
                                                                                            iPrecision := 2,
                                                                                            bLoCase := FALSE)),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_DATE" Id="{1645ab79-f969-41aa-a170-f589a5757e7f}">
      <Declaration><![CDATA[(*
    Asserts that two DATEs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_DATE
VAR_INPUT
    Expected : DATE; // DATE expected value
    Actual : DATE; // DATE actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := DATE_TO_STRING(Expected),
                                            Actual := DATE_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_DATE_AND_TIME" Id="{42befc01-2199-49e2-b7ef-cf909b8890f9}">
      <Declaration><![CDATA[(*
    Asserts that two DATE_AND_TIMEs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_DATE_AND_TIME
VAR_INPUT
    Expected : DATE_AND_TIME; // DATE_AND_TIME expected value
    Actual : DATE_AND_TIME; // DATE_AND_TIME actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := DT_TO_STRING(Expected),
                                            Actual := DT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_DINT" Id="{b7177b75-64df-4021-85c6-c366f61f5f89}">
      <Declaration><![CDATA[(*
    Asserts that two DINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_DINT
VAR_INPUT
    Expected : DINT; // DINT expected value
    Actual : DINT; // DINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := DINT_TO_STRING(Expected),
                                            Actual := DINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_DWORD" Id="{3ce6ba77-0ab2-46fc-a7c9-978b376b93be}">
      <Declaration><![CDATA[(*
    Asserts that two DWORDs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_DWORD
VAR_INPUT
    Expected : DWORD; // DWORD expected value
    Actual : DWORD; // DWORD actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := Tc2_Standard.CONCAT(
                                                            STR1 := '0x',
                                                            STR2 := Tc2_Utilities.DWORD_TO_HEXSTR(in := Expected,
                                                                                                  iPrecision := 8,
                                                                                                  bLoCase := FALSE)),
                                            Actual := Tc2_Standard.CONCAT(
                                                           STR1 := '0x',
                                                           STR2 := Tc2_Utilities.DWORD_TO_HEXSTR(in := Actual,
                                                                                                 iPrecision := 8,
                                                                                                 bLoCase := FALSE)),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_INT" Id="{7c61106e-9bcd-4577-a949-ab96d8862e41}">
      <Declaration><![CDATA[(*
    Asserts that two INTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_INT
VAR_INPUT
    Expected : INT; // INT expected value
    Actual : INT; // INT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := INT_TO_STRING(Expected),
                                            Actual := INT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_LINT" Id="{9dc34017-cbc7-41a9-83a2-941f39cc7271}">
      <Declaration><![CDATA[(*
    Asserts that two LINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_LINT
VAR_INPUT
    Expected : LINT; // LINT expected value
    Actual : LINT; // LINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := LINT_TO_STRING(Expected),
                                            Actual := LINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_LREAL" Id="{205d107c-0a2d-44f7-b68a-eb06720b6a6b}">
      <Declaration><![CDATA[(*
    Asserts that two LREALs are equal to within a positive delta. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_LREAL
VAR_INPUT
    Expected : LREAL; // LREAL expected value
    Actual : LREAL; // LREAL actual value
    Delta : LREAL; // The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF ABS(Expected - Actual) > Delta THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND ABS(Expected - Actual) > Delta THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := LREAL_TO_STRING(Expected),
                                            Actual := LREAL_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_LTIME" Id="{05ea6378-c553-40a9-9e6b-8f3736f63098}">
      <Declaration><![CDATA[(*
    Asserts that two LTIMEs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_LTIME
VAR_INPUT
    Expected : LTIME; // LTIME expected value
    Actual : LTIME; // LTIME actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := LTIME_TO_STRING(Expected),
                                            Actual := LTIME_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_LWORD" Id="{08b090fb-911b-49fa-a51a-7f5edfd3dd2c}">
      <Declaration><![CDATA[(*
    Asserts that two LWORDs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_LWORD
VAR_INPUT
    Expected : LWORD; // LWORD expected value
    Actual : LWORD; // LWORD actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := Tc2_Standard.CONCAT(
                                                            STR1 := '0x',
                                                            STR2 := Tc2_Utilities.LWORD_TO_HEXSTR(in := Expected,
                                                                                                  iPrecision := 16,
                                                                                                  bLoCase := FALSE)),
                                            Actual := Tc2_Standard.CONCAT(
                                                            STR1 := '0x',
                                                            STR2 := Tc2_Utilities.LWORD_TO_HEXSTR(in := Actual,
                                                                                                  iPrecision := 16,
                                                                                                  bLoCase := FALSE)),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_REAL" Id="{fba4feaf-27d0-4f8b-9014-3895f7bb9cc7}">
      <Declaration><![CDATA[(*
    Asserts that two REALs are equal to within a positive delta. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_REAL
VAR_INPUT
    Expected : REAL; // REAL expected value
    Actual : REAL; // REAL actual value
    Delta : REAL;  // The maximum delta between the absolute value of expected and actual for which both numbers are still considered equal
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF ABS(Expected - Actual) > Delta THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND ABS(Expected - Actual) > Delta THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := REAL_TO_STRING(Expected),
                                            Actual := REAL_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_SINT" Id="{10052dfe-cfcb-4a5a-aa97-151e272ce217}">
      <Declaration><![CDATA[(*
    Asserts that two SINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_SINT
VAR_INPUT
    Expected : SINT; // SINT expected value
    Actual : SINT; // SINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := SINT_TO_STRING(Expected),
                                            Actual := SINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_STRING" Id="{cad7fed3-5db3-4371-9240-856c3c740489}">
      <Declaration><![CDATA[(*
    Asserts that two STRINGs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_STRING
VAR_INPUT
    Expected : Tc2_System.T_MaxString; // STRING expected value
    Actual : Tc2_System.T_MaxString; // STRING actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF (Tc2_Standard.LEN(STR := Expected) <> Tc2_Standard.LEN(STR := Actual) OR (Expected <> Actual)) THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND (Tc2_Standard.LEN(STR := Expected) <> Tc2_Standard.LEN(STR := Actual) OR (Expected <> Actual)) THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := Expected,
                                            Actual := Actual,
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_TIME" Id="{717a0cdd-16a7-4f45-90f3-f5700dba9369}">
      <Declaration><![CDATA[(*
    Asserts that two TIMEs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_TIME
VAR_INPUT
    Expected : TIME; // TIME expected value
    Actual : TIME; // TIME actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := TIME_TO_STRING(Expected),
                                            Actual := TIME_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_TIME_OF_DAY" Id="{d892dd01-3d32-4eb1-9f95-980dff16616c}">
      <Declaration><![CDATA[(*
    Asserts that two TIME_OF_DAYs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_TIME_OF_DAY
VAR_INPUT
    Expected : TIME_OF_DAY; // TIME_OF_DAY expected value
    Actual : TIME_OF_DAY; // TIME_OF_DAY actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := TOD_TO_STRING(Expected),
                                            Actual := TOD_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_UDINT" Id="{9c21e8db-62d7-4e5c-8e00-cd508f4f5abc}">
      <Declaration><![CDATA[(*
    Asserts that two UDINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_UDINT
VAR_INPUT
    Expected : UDINT; // UDINT expected value
    Actual : UDINT; // UDINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := UDINT_TO_STRING(Expected),
                                            Actual := UDINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_UINT" Id="{86b960b9-ebc0-46af-91ed-94a423f501dc}">
      <Declaration><![CDATA[(*
    Asserts that two UINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_UINT
VAR_INPUT
    Expected : UINT; // UINT expected value
    Actual : UINT; // UINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := UINT_TO_STRING(Expected),
                                            Actual := UINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_ULINT" Id="{6f1e7566-33c3-4f9c-b92d-7828feb26211}">
      <Declaration><![CDATA[(*
    Asserts that two ULINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_ULINT
VAR_INPUT
    Expected : ULINT; // ULINT expected value
    Actual : ULINT; // ULINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := ULINT_TO_STRING(Expected),
                                            Actual := ULINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_USINT" Id="{7f12117a-f0ab-475b-ba47-c8a5c801a9ac}">
      <Declaration><![CDATA[(*
    Asserts that two USINTs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_USINT
VAR_INPUT
    Expected : USINT; // USINT expected value
    Actual : USINT; // USINT actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    AlreadyReported : BOOL;
    TestInstancePath : Tc2_System.T_MaxString;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := USINT_TO_STRING(Expected),
                                            Actual := USINT_TO_STRING(Actual),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertEquals_WORD" Id="{85132cdb-0553-4070-be9a-976fcddd873d}">
      <Declaration><![CDATA[(*
    Asserts that two WORDs are equal. If they are not, an assertion error is created.
*)
METHOD PUBLIC AssertEquals_WORD
VAR_INPUT
    Expected : WORD; // WORD expected value
    Actual : WORD; // WORD actual value
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR
VAR
    TestInstancePath : Tc2_System.T_MaxString;
    AlreadyReported : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL_TcUnit.IgnoreCurrentTest THEN
    RETURN;
END_IF

TestInstancePath := AddTestNameToInstancePath(TestInstancePath := FindTestSuiteInstancePath());

IF Expected <> Actual THEN
    AssertResults.ReportResult(Expected := Expected,
                               Actual := Actual,
                               Message := Message,
                               TestInstancePath := TestInstancePath,
                               AlreadyReported => AlreadyReported);
END_IF

IF NOT AlreadyReported AND Expected <> Actual THEN
    SetTestFailed();

    AssertMessageFormatter.LogAssertFailure(Expected := Tc2_Standard.CONCAT(
                                                            STR1 := '0x',
                                                            STR2 := Tc2_Utilities.WORD_TO_HEXSTR(in := Expected,
                                                                                                 iPrecision := 4,
                                                                                                 bLoCase := FALSE)),
                                            Actual := Tc2_Standard.CONCAT(
                                                            STR1 := '0x',
                                                            STR2 := Tc2_Utilities.WORD_TO_HEXSTR(in := Actual,
                                                                                                 iPrecision := 4,
                                                                                                 bLoCase := FALSE)),
                                            Message := Message,
                                            TestInstancePath := TestInstancePath);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertFalse" Id="{022665a8-9003-4aaa-8ef4-bd39fe196883}">
      <Declaration><![CDATA[(*
    Asserts that a condition is false. If it is not, an assertion error is created.
*)
METHOD PUBLIC AssertFalse
VAR_INPUT
    Condition : BOOL; // Condition to be checked
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[AssertEquals_BOOL(Expected := FALSE, Actual := Condition, Message := Message);]]></ST>
      </Implementation>
    </Method>
    <Method Name="AssertTrue" Id="{c415013c-c271-42ba-83ad-6c2c653d8f2e}">
      <Declaration><![CDATA[(*
    Asserts that a condition is true. If it is not, an assertion error is created.
*)
METHOD PUBLIC AssertTrue
VAR_INPUT
    Condition : BOOL; // Condition to be checked
    Message : Tc2_System.T_MaxString; // The identifying message for the assertion error
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[AssertEquals_BOOL(Expected := TRUE, Actual := Condition, Message := Message);]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{9273f5af-0583-448b-bab6-3359f03f9b91}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
    bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
    bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GVL_TcUnit.NumberOfInitializedTestSuites := GVL_TcUnit.NumberOfInitializedTestSuites + 1;    
GVL_TcUnit.TestSuiteAddresses[GVL_TcUnit.NumberOfInitializedTestSuites] := THIS;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FindTestSuiteInstancePath" Id="{e69a4510-81a2-4d65-94e4-52c06ac49944}">
      <Declaration><![CDATA[(* Searches for the instance path of the calling function block *)
METHOD PRIVATE FindTestSuiteInstancePath : Tc2_System.T_MaxString]]></Declaration>
      <Implementation>
        <ST><![CDATA[FindTestSuiteInstancePath := GetInstancePath();]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetInstancePath" Id="{178fa338-5ed3-417b-8f4d-e9f120ace4b9}">
      <Declaration><![CDATA[METHOD PUBLIC GetInstancePath : Tc2_System.T_MaxString
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetInstancePath := InstancePath;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNumberOfFailedTests" Id="{12e4522b-e67f-439a-af1d-8713231888aa}">
      <Declaration><![CDATA[METHOD PUBLIC GetNumberOfFailedTests : UINT
VAR
    Counter : UINT;
    FailedTestsCount : UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NumberOfTests > 0 THEN
    FOR Counter := 1 TO GetNumberOfTests() BY 1 DO
        IF Tests[Counter].IsFailed() THEN
            FailedTestsCount := FailedTestsCount + 1;
        END_IF
    END_FOR
END_IF

GetNumberOfFailedTests := FailedTestsCount;]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNumberOfSuccessfulTests" Id="{635213dc-96ca-4be6-9c0d-c0454c29d34d}">
      <Declaration><![CDATA[METHOD PUBLIC GetNumberOfSuccessfulTests : UINT]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetNumberOfSuccessfulTests := GetNumberOfTests() - GetNumberOfFailedTests();]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetNumberOfTests" Id="{6f67c6d5-c29e-4577-8651-51bd6db3ab63}">
      <Declaration><![CDATA[METHOD PUBLIC GetNumberOfTests : UINT]]></Declaration>
      <Implementation>
        <ST><![CDATA[GetNumberOfTests := NumberOfTests;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetTestFailed" Id="{79b1664f-2570-4cef-bd6e-d7307d9a7818}">
      <Declaration><![CDATA[METHOD PUBLIC SetTestFailed
VAR
    IteratorCounter : UINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NumberOfTests > 0 THEN
    FOR IteratorCounter := 1 TO NumberOfTests BY 1 DO
        IF Tests[IteratorCounter].GetName() = GVL_TcUnit.CurrentTestNameBeingCalled THEN
            Tests[IteratorCounter].SetFailed();
        END_IF
    END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetTestFinished" Id="{1ec94335-80d7-46d3-a0f0-345f8eda2ea4}">
      <Declaration><![CDATA[METHOD PUBLIC SetTestFinished
VAR_INPUT
    TestName : Tc2_System.T_MaxString;
END_VAR
VAR
    IteratorCounter : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NumberOfTests > 0 THEN
    FOR IteratorCounter := 1 TO NumberOfTests BY 1 DO
        IF Tests[IteratorCounter].GetName() = TestName THEN
            Tests[IteratorCounter].SetFinished();
        END_IF
    END_FOR
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_TestSuite">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AddTest">
      <LineId Id="157" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="217" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="167" Count="1" />
      <LineId Id="170" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="142" Count="0" />
      <LineId Id="127" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="159" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="232" Count="1" />
      <LineId Id="96" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="144" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AddTestNameToInstancePath">
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AllTestsFinished">
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="6" Count="1" />
      <LineId Id="10" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="36" Count="1" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArray2dEquals_LREAL">
      <LineId Id="1208" Count="47" />
      <LineId Id="1353" Count="0" />
      <LineId Id="1257" Count="31" />
      <LineId Id="1420" Count="0" />
      <LineId Id="1422" Count="10" />
      <LineId Id="1421" Count="0" />
      <LineId Id="1290" Count="9" />
      <LineId Id="1434" Count="11" />
      <LineId Id="1433" Count="0" />
      <LineId Id="1301" Count="0" />
      <LineId Id="1446" Count="0" />
      <LineId Id="1303" Count="2" />
      <LineId Id="1383" Count="0" />
      <LineId Id="1307" Count="0" />
      <LineId Id="1449" Count="3" />
      <LineId Id="1455" Count="0" />
      <LineId Id="1448" Count="0" />
      <LineId Id="1447" Count="0" />
      <LineId Id="1310" Count="0" />
      <LineId Id="1352" Count="0" />
      <LineId Id="1312" Count="1" />
      <LineId Id="1384" Count="0" />
      <LineId Id="1315" Count="0" />
      <LineId Id="1458" Count="4" />
      <LineId Id="1457" Count="0" />
      <LineId Id="1317" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArray2dEquals_REAL">
      <LineId Id="1208" Count="80" />
      <LineId Id="1389" Count="11" />
      <LineId Id="1388" Count="0" />
      <LineId Id="1290" Count="9" />
      <LineId Id="1402" Count="11" />
      <LineId Id="1401" Count="0" />
      <LineId Id="1387" Count="0" />
      <LineId Id="1301" Count="0" />
      <LineId Id="1354" Count="1" />
      <LineId Id="1302" Count="5" />
      <LineId Id="1415" Count="4" />
      <LineId Id="1414" Count="0" />
      <LineId Id="1309" Count="6" />
      <LineId Id="1421" Count="4" />
      <LineId Id="1420" Count="0" />
      <LineId Id="1317" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArray3dEquals_LREAL">
      <LineId Id="1138" Count="94" />
      <LineId Id="1338" Count="17" />
      <LineId Id="1337" Count="0" />
      <LineId Id="1234" Count="12" />
      <LineId Id="1357" Count="17" />
      <LineId Id="1356" Count="0" />
      <LineId Id="1248" Count="0" />
      <LineId Id="1303" Count="1" />
      <LineId Id="1249" Count="6" />
      <LineId Id="1376" Count="6" />
      <LineId Id="1375" Count="0" />
      <LineId Id="1257" Count="7" />
      <LineId Id="1385" Count="3" />
      <LineId Id="1391" Count="0" />
      <LineId Id="1390" Count="0" />
      <LineId Id="1389" Count="0" />
      <LineId Id="1384" Count="0" />
      <LineId Id="1266" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArray3dEquals_REAL">
      <LineId Id="1167" Count="94" />
      <LineId Id="1402" Count="17" />
      <LineId Id="1401" Count="0" />
      <LineId Id="1263" Count="12" />
      <LineId Id="1383" Count="17" />
      <LineId Id="1382" Count="0" />
      <LineId Id="1277" Count="0" />
      <LineId Id="1332" Count="1" />
      <LineId Id="1278" Count="6" />
      <LineId Id="1374" Count="6" />
      <LineId Id="1373" Count="0" />
      <LineId Id="1286" Count="7" />
      <LineId Id="1366" Count="6" />
      <LineId Id="1365" Count="0" />
      <LineId Id="1295" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_BOOL">
      <LineId Id="243" Count="3" />
      <LineId Id="199" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="301" Count="0" />
      <LineId Id="271" Count="0" />
      <LineId Id="270" Count="0" />
      <LineId Id="272" Count="2" />
      <LineId Id="277" Count="0" />
      <LineId Id="275" Count="1" />
      <LineId Id="302" Count="0" />
      <LineId Id="109" Count="5" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="115" Count="15" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_BYTE">
      <LineId Id="263" Count="1" />
      <LineId Id="262" Count="0" />
      <LineId Id="265" Count="0" />
      <LineId Id="216" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="326" Count="0" />
      <LineId Id="294" Count="6" />
      <LineId Id="293" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="165" Count="3" />
      <LineId Id="120" Count="10" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_DINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="313" Count="0" />
      <LineId Id="283" Count="6" />
      <LineId Id="103" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="314" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_DWORD">
      <LineId Id="261" Count="1" />
      <LineId Id="260" Count="0" />
      <LineId Id="263" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="216" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="226" Count="1" />
      <LineId Id="231" Count="1" />
      <LineId Id="234" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="289" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="321" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="165" Count="3" />
      <LineId Id="120" Count="10" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_INT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_LINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_LREAL">
      <LineId Id="40" Count="61" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_LWORD">
      <LineId Id="261" Count="1" />
      <LineId Id="260" Count="0" />
      <LineId Id="263" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="216" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="226" Count="1" />
      <LineId Id="231" Count="1" />
      <LineId Id="234" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="289" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="322" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="165" Count="3" />
      <LineId Id="120" Count="10" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_REAL">
      <LineId Id="40" Count="61" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_SINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_UDINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_UINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_ULINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_USINT">
      <LineId Id="257" Count="1" />
      <LineId Id="256" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="212" Count="20" />
      <LineId Id="102" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="283" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="313" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="190" Count="0" />
      <LineId Id="116" Count="14" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertArrayEquals_WORD">
      <LineId Id="261" Count="1" />
      <LineId Id="260" Count="0" />
      <LineId Id="263" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="216" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="218" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="1" />
      <LineId Id="226" Count="1" />
      <LineId Id="231" Count="1" />
      <LineId Id="234" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="228" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="229" Count="0" />
      <LineId Id="102" Count="0" />
      <LineId Id="320" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="289" Count="5" />
      <LineId Id="108" Count="1" />
      <LineId Id="321" Count="0" />
      <LineId Id="110" Count="4" />
      <LineId Id="149" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="154" Count="1" />
      <LineId Id="159" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="163" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="116" Count="3" />
      <LineId Id="165" Count="3" />
      <LineId Id="120" Count="10" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals">
      <LineId Id="521" Count="1" />
      <LineId Id="519" Count="0" />
      <LineId Id="523" Count="0" />
      <LineId Id="233" Count="1" />
      <LineId Id="304" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="305" Count="0" />
      <LineId Id="511" Count="2" />
      <LineId Id="515" Count="0" />
      <LineId Id="237" Count="0" />
      <LineId Id="306" Count="0" />
      <LineId Id="243" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="212" Count="0" />
      <LineId Id="241" Count="0" />
      <LineId Id="208" Count="0" />
      <LineId Id="242" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="244" Count="1" />
      <LineId Id="247" Count="4" />
      <LineId Id="246" Count="0" />
      <LineId Id="575" Count="0" />
      <LineId Id="577" Count="5" />
      <LineId Id="576" Count="0" />
      <LineId Id="585" Count="0" />
      <LineId Id="587" Count="5" />
      <LineId Id="586" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="266" Count="5" />
      <LineId Id="265" Count="0" />
      <LineId Id="295" Count="0" />
      <LineId Id="297" Count="5" />
      <LineId Id="296" Count="0" />
      <LineId Id="307" Count="0" />
      <LineId Id="309" Count="5" />
      <LineId Id="308" Count="0" />
      <LineId Id="315" Count="0" />
      <LineId Id="317" Count="5" />
      <LineId Id="316" Count="0" />
      <LineId Id="389" Count="0" />
      <LineId Id="391" Count="5" />
      <LineId Id="390" Count="0" />
      <LineId Id="597" Count="0" />
      <LineId Id="599" Count="5" />
      <LineId Id="598" Count="0" />
      <LineId Id="323" Count="0" />
      <LineId Id="325" Count="5" />
      <LineId Id="324" Count="0" />
      <LineId Id="399" Count="0" />
      <LineId Id="401" Count="5" />
      <LineId Id="400" Count="0" />
      <LineId Id="331" Count="0" />
      <LineId Id="333" Count="5" />
      <LineId Id="332" Count="0" />
      <LineId Id="380" Count="0" />
      <LineId Id="382" Count="5" />
      <LineId Id="381" Count="0" />
      <LineId Id="606" Count="6" />
      <LineId Id="605" Count="0" />
      <LineId Id="615" Count="0" />
      <LineId Id="617" Count="5" />
      <LineId Id="616" Count="0" />
      <LineId Id="340" Count="0" />
      <LineId Id="342" Count="5" />
      <LineId Id="341" Count="0" />
      <LineId Id="348" Count="0" />
      <LineId Id="350" Count="5" />
      <LineId Id="349" Count="0" />
      <LineId Id="356" Count="0" />
      <LineId Id="358" Count="5" />
      <LineId Id="357" Count="0" />
      <LineId Id="364" Count="0" />
      <LineId Id="366" Count="5" />
      <LineId Id="365" Count="0" />
      <LineId Id="373" Count="6" />
      <LineId Id="372" Count="0" />
      <LineId Id="339" Count="0" />
      <LineId Id="239" Count="0" />
      <LineId Id="517" Count="1" />
      <LineId Id="516" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="49" Count="0" />
      <LineId Id="59" Count="1" />
      <LineId Id="54" Count="4" />
      <LineId Id="53" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="458" Count="0" />
      <LineId Id="152" Count="4" />
      <LineId Id="151" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="459" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="132" Count="1" />
      <LineId Id="96" Count="2" />
      <LineId Id="93" Count="0" />
      <LineId Id="99" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_BOOL">
      <LineId Id="85" Count="1" />
      <LineId Id="84" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="56" Count="3" />
      <LineId Id="25" Count="0" />
      <LineId Id="101" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="70" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="2" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_BYTE">
      <LineId Id="81" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="53" Count="3" />
      <LineId Id="52" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="66" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_DATE">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_DATE_AND_TIME">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_DINT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_DWORD">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_INT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="3" />
      <LineId Id="43" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_LINT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_LREAL">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="46" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="61" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_LTIME">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_LWORD">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_REAL">
      <LineId Id="81" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="51" Count="3" />
      <LineId Id="45" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="65" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_SINT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_STRING">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_TIME">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_TIME_OF_DAY">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="110" Count="3" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_UDINT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_UINT">
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_ULINT">
      <LineId Id="73" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="43" Count="4" />
      <LineId Id="42" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_USINT">
      <LineId Id="91" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="73" Count="3" />
      <LineId Id="41" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="15" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertEquals_WORD">
      <LineId Id="77" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="19" Count="1" />
      <LineId Id="13" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertFalse">
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.AssertTrue">
      <LineId Id="12" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.FB_init">
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.FindTestSuiteInstancePath">
      <LineId Id="36" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.GetInstancePath">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.GetNumberOfFailedTests">
      <LineId Id="10" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="13" Count="4" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.GetNumberOfSuccessfulTests">
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.GetNumberOfTests">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.SetTestFailed">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="22" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_TestSuite.SetTestFinished">
      <LineId Id="6" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>